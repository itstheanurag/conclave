import { useEffect, useState, useRef, useCallback } from "react";
import { MediasoupClient } from "../lib/mediasoup-client";
import { MediasoupClientOptions, MeetingParticipant } from "../types/mediasoup";

export const useMediasoup = ({
  roomId,
  peerId,
  websocketUrl,
}: MediasoupClientOptions) => {
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  // We keep a separate array for raw remote streams if needed for grids
  const [remoteStreams, setRemoteStreams] = useState<MediaStream[]>([]);

  // The main participant map
  const [participants, setParticipants] = useState<
    Map<string, MeetingParticipant>
  >(new Map());

  const [isMicEnabled, setIsMicEnabled] = useState(false);
  const [isWebcamEnabled, setIsWebcamEnabled] = useState(false);
  const [isScreenSharing, setIsScreenSharing] = useState(false);

  const clientRef = useRef<MediasoupClient | null>(null);

  /* -----------------------------------------------------
   * Participant helpers
   * ----------------------------------------------------- */

  const updateParticipant = useCallback(
    (pId: string, track: MediaStreamTrack, screenShare = false) => {
      setParticipants((prev) => {
        const updated = new Map(prev);

        let participant = updated.get(pId);

        // Create new participant if not exists
        if (!participant) {
          participant = {
            id: pId,
            name: pId === peerId ? "You" : `Guest-${pId.slice(0, 5)}`,
            stream: new MediaStream(),
            isLocal: pId === peerId,
            isScreenShare: false,
            // Defaults
            isMuted: false,
            isVideoOff: false,
            isHost: false,
          };
        }

        // We need to clone the stream to trigger React updates properly if we were relying solely on stream ref
        // But since we are updating the Map, we just need to ensure the stream inside is mutated correctly.

        // 1. Remove existing track of the same kind (e.g., switching cameras)
        const oldTrack = participant
          .stream!.getTracks()
          .find((t) => t.kind === track.kind);
        if (oldTrack) {
          participant.stream!.removeTrack(oldTrack);
        }

        // 2. Add the new track
        participant.stream!.addTrack(track);

        if (screenShare) participant.isScreenShare = true;

        updated.set(pId, participant);
        return updated;
      });
    },
    [peerId]
  );

  const removeTrack = useCallback((trackIdToClose: string) => {
    setParticipants((prev) => {
      const updated = new Map(prev);

      for (const [pid, p] of updated) {
        if (!p.stream) continue;

        // In our MediasoupClient, we mapped consumers by producerId.
        // We check if any track in this participant's stream matches the closed ID.
        // Note: verify if track.id matches producerId in your actual browser behavior.
        // Often track.id is generated by the browser.
        // If track.id != producerId, you might need to map them separately.
        // Assuming here that trackIdToClose allows us to identify the track (via logic or explicit map).

        // For this implementation, we will try to match by track ID strictly.
        // If your MediasoupClient implementation ensures track.id === producerId, this works.
        const track = p.stream.getTracks().find((t) => t.id === trackIdToClose);

        // Fallback: If track.id is random (common in WebRTC), we might just remove
        // the track of the specific kind if we knew the kind, but we don't here.
        // For now, we rely on the client ensuring reference equality or ID match.

        if (track) {
          p.stream.removeTrack(track);

          // If no tracks left, remove participant (unless it's the local user, usually we keep them)
          if (p.stream.getTracks().length === 0 && !p.isLocal) {
            updated.delete(pid);
          } else {
            // Force update
            updated.set(pid, p);
          }
        }
      }
      return updated;
    });
  }, []);

  /* -----------------------------------------------------
   * Setup mediasoup client
   * ----------------------------------------------------- */
  useEffect(() => {
    // Initialize Client
    const client = new MediasoupClient({
      roomId,
      peerId,
      websocketUrl,
    });

    clientRef.current = client;

    /* --- Event Handlers --- */

    // 1. Local Media Created
    client.on("localStream", (stream) => {
      if (!stream) return;
      setLocalStream(stream);
      // Add local tracks to participants map so "You" appear in the grid
      stream.getTracks().forEach((track) => {
        updateParticipant(peerId, track, false);
      });
    });

    // 2. New Remote Consumer
    client.on("newConsumer", ({ peerId: remoteId, kind, track }) => {
      // Heuristic for screen sharing detection if not passed explicitly.
      // Ideally, pass 'appData' through the event.
      const isScreen =
        kind === "video" && track.label.toLowerCase().includes("screen");

      setRemoteStreams((prev) => [...prev, new MediaStream([track])]);
      updateParticipant(remoteId, track, isScreen);
    });

    // 3. Consumer Closed (Remote stopped sending)
    client.on("consumerClosed", ({ consumerId }) => {
      // Logic: consumerId here corresponds to the key in MediasoupClient.consumers map.
      // Depending on implementation, this might be the producerId.
      removeTrack(consumerId);
    });

    return () => {
      client.close();
    };
  }, [roomId, peerId, websocketUrl, updateParticipant, removeTrack]);

  /* -----------------------------------------------------
   * Media controls
   * ----------------------------------------------------- */

  const startMedia = useCallback(async (cam: boolean, mic: boolean) => {
    const client = clientRef.current;
    if (!client) return;

    if (cam) {
      await client.enableWebcam();
      setIsWebcamEnabled(true);
    }
    if (mic) {
      await client.enableMic();
      setIsMicEnabled(true);
    }
  }, []);

  const stopMedia = useCallback(async () => {
    const client = clientRef.current;
    if (!client) return;

    await client.disableWebcam();
    await client.disableMic();

    setIsWebcamEnabled(false);
    setIsMicEnabled(false);
  }, []);

  const toggleMic = useCallback(async () => {
    const client = clientRef.current;
    if (!client) return;

    if (isMicEnabled) {
      await client.disableMic();
      setIsMicEnabled(false);
    } else {
      await client.enableMic();
      setIsMicEnabled(true);
    }
  }, [isMicEnabled]);

  const toggleCamera = useCallback(async () => {
    const client = clientRef.current;
    if (!client) return;

    if (isWebcamEnabled) {
      await client.disableWebcam();
      setIsWebcamEnabled(false);
    } else {
      await client.enableWebcam();
      setIsWebcamEnabled(true);
    }
  }, [isWebcamEnabled]);

  const startScreenShare = useCallback(async () => {
    await clientRef.current?.enableScreenShare();
    setIsScreenSharing(true);
  }, []);

  const stopScreenShare = useCallback(async () => {
    await clientRef.current?.disableScreenShare();
    setIsScreenSharing(false);
  }, []);

  return {
    localStream,
    remoteStreams,
    participants, // Map<string, MeetingParticipant>

    // Toggles state
    isMicEnabled,
    isWebcamEnabled,
    isScreenSharing,

    // Methods
    startMedia,
    stopMedia,
    startScreenShare,
    stopScreenShare,
    toggleMic,
    toggleCamera,
  };
};
